请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下
移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格
子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的
路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行
第二个格子之后，路径不能再次进入该格子。
思路:用回溯法，
首先我们先在矩阵中任选一个格子作为起点，假设该格子字符为q，这个各自对应字符串路径
第i个字符，如果路径上第i个字符不是ch,那么这个格子不可能处在路径上的第i个位置，如果
正好是ch,那么再到相邻的格子找路径上下一个字符，除边界外，其余的格子都有4个相邻的格子
重复这个过程，直到路径上所有字符都在矩阵中找到相应的位置，
由于回溯法的递归特性，路径可以被看成一个栈，当在矩阵汇总定位了路径的前n个字符位置后，
在第n个字符周围都没找到第n+1个字符，这时候只好回到路径上第n-1个字符，重新定位第n个字符。
由于路径不能重复进入矩阵中的格子，所以还需要一个int矩阵标记出已经符合路径中字符的格子。
标记为1后，此后不能再进入此格子。
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        if(matrix==null||rows<1||cols<1||str==null)
            return false;
        int[][] flag=new int[rows][cols];//标记矩阵
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(Search(matrix,rows,cols,i,j,str,0,flag)){
                    return true;
                }
            }
        }
        return false;
    }
    private boolean Search(char[] matrix,int rows,int cols,int i,int j,
                           char[] str,int index,int[][]flag){
        if(i<0||j<0||i>=rows||j>=cols||flag[i][j]==1||matrix[i*cols+j]!=str[index]){
            return false;
        }
        if(index==str.length-1)
            return true;
        flag[i][j]=1;//进入了此格子所以做标记
        if(Search(matrix,rows,cols,i-1,j,str,index+1,flag)||
          Search(matrix,rows,cols,i,j-1,str,index+1,flag)||
          Search(matrix,rows,cols,i,j+1,str,index+1,flag)||
          Search(matrix,rows,cols,i+1,j,str,index+1,flag))
            return true;
        flag[i][j]=0;//此格子周围没有找到符合，要回到上一个字符重新定位，
                     //这个格子重新标记为0，表示没有进入,下一次搜索时，还可以进入
        return false;
    }
}